import { hex2rgba, toArray } from '@unocss/core';
import { h as handler, d as directionMap, c as cornerMap, a as capitalize, b as directionSize, x as xyzMap } from './utilities.mjs';
import { C as CONTROL_BYPASS_PSEUDO_CLASS } from './pseudo.mjs';

const verticalAlignAlias = {
  mid: "middle",
  base: "baseline",
  btm: "bottom"
};
const verticalAligns = [
  [/^(?:vertical|align|v)-(baseline|top|bottom|middle|text-top|text-bottom|mid|base|btm)$/, ([, v]) => ({ "vertical-align": verticalAlignAlias[v] || v })]
];
const textAligns = [
  ["text-center", { "text-align": "center" }],
  ["text-left", { "text-align": "left" }],
  ["text-right", { "text-align": "right" }],
  ["text-justify", { "text-align": "justify" }]
];

const parseColorUtil = (body, theme) => {
  const [main, opacity2] = body.split(/(?:\/|:)/);
  const colors = main.replace(/([a-z])([0-9])/g, "$1-$2").split(/-/g);
  const [name] = colors;
  if (!name)
    return;
  let color;
  const bracket = handler.bracket(main);
  const bracketOrMain = bracket || main;
  if (bracketOrMain.startsWith("#"))
    color = bracketOrMain.slice(1);
  if (bracketOrMain.startsWith("hex-"))
    color = bracketOrMain.slice(4);
  color = color || bracket;
  let no = "DEFAULT";
  if (!color) {
    let colorData = theme.colors?.[name];
    if (colorData) {
      [, no = no] = colors;
    } else {
      if (colors.slice(-1)[0].match(/^\d+$/))
        no = colors.pop();
      colorData = theme.colors?.[colors.join("-").replace(/(-[a-z])/g, (n) => n.slice(1).toUpperCase())];
    }
    if (typeof colorData === "string")
      color = colorData;
    else if (no && colorData)
      color = colorData[no];
  }
  return {
    opacity: opacity2,
    name,
    no,
    color,
    rgba: hex2rgba(color)
  };
};
const colorResolver$1 = (attribute, varName) => ([, body], { theme }) => {
  const data = parseColorUtil(body, theme);
  if (!data)
    return;
  const { opacity: opacity2, color, rgba } = data;
  if (!color)
    return;
  const a = opacity2 ? opacity2[0] === "[" ? handler.bracket.percent(opacity2) : parseFloat(opacity2) / 100 : rgba?.[3];
  if (rgba) {
    if (a != null && !Number.isNaN(a)) {
      rgba[3] = typeof a === "string" && !a.includes("%") ? parseFloat(a) : a;
      return {
        [attribute]: `rgba(${rgba.join(",")})`
      };
    } else {
      return {
        [`--un-${varName}-opacity`]: 1,
        [attribute]: `rgba(${rgba.slice(0, 3).join(",")},var(--un-${varName}-opacity))`
      };
    }
  } else {
    return {
      [attribute]: color.replace("%alpha", `${a || 1}`)
    };
  }
};
const opacity = [
  [/^op(?:acity)?-?(.+)$/, ([, d]) => ({ opacity: handler.bracket.percent.cssvar(d) })]
];
const textColors = [
  [/^(?:text|color|c)-(.+)$/, colorResolver$1("color", "text")],
  [/^(?:text|color|c)-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-text-opacity": handler.bracket.percent.cssvar(opacity2) })]
];
const bgColors = [
  [/^bg-(.+)$/, colorResolver$1("background-color", "bg")],
  [/^bg-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-bg-opacity": handler.bracket.percent(opacity2) })]
];
const borderColors = [
  [/^(?:border|b)-(.+)$/, colorResolver$1("border-color", "border")],
  [/^(?:border|b)-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-border-opacity": handler.bracket.percent(opacity2) })]
];
const ringColors = [
  [/^ring-(.+)$/, colorResolver$1("--un-ring-color", "ring")],
  [/^ring-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-ring-opacity": handler.bracket.percent(opacity2) })]
];
const ringOffsetColors = [
  [/^ring-offset-(.+)$/, colorResolver$1("--un-ring-offset-color", "ring-offset")],
  [/^ring-offset-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-ring-offset-opacity": handler.bracket.percent(opacity2) })]
];

const cssBasicProps = [
  "color",
  "border-color",
  "background-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow"
];
const cssPositionProps = [
  "backround-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position"
];
const cssSizeProps = [
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing"
];
const cssEnhanceProps = ["stroke", "filter", "backdrop-filter", "fill", "mask", "mask-size", "mask-border", "clip-path", "clip"];
const cssProps = [
  ...cssBasicProps,
  ...cssPositionProps,
  ...cssSizeProps,
  ...cssEnhanceProps
];
const varEmpty = "var(--un-empty,/*!*/ /*!*/)";
const displays = [
  ["inline", { display: "inline" }],
  ["block", { display: "block" }],
  ["inline-block", { display: "inline-block" }],
  ["contents", { display: "contents" }],
  ["flow-root", { display: "flow-root" }],
  ["list-item", { display: "list-item" }],
  ["hidden", { display: "none" }]
];
const appearances = [
  ["visible", { visibility: "visible" }],
  ["invisible", { visibility: "hidden" }],
  ["backface-visible", { "backface-visibility": "visible" }],
  ["backface-hidden", { "backface-visibility": "hidden" }]
];
const cursors = [
  [/^cursor-(.+)$/, ([, c]) => ({ cursor: c })]
];
const pointerEvents = [
  ["pointer-events-none", { "pointer-events": "none" }],
  ["pointer-events-auto", { "pointer-events": "auto" }]
];
const resizes = [
  ["resize-none", { resize: "none" }],
  ["resize-x", { resize: "horizontal" }],
  ["resize-y", { resize: "vertical" }],
  ["resize", { resize: "both" }]
];
const userSelects = [
  [/^select-(none|text|all|auto)$/, ([, v]) => ({ "user-select": v })]
];
const whitespaces = [
  [/^(?:whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap)$/, ([, v]) => ({ "white-space": v })]
];
const contents = [
  ["content-empty", { content: '""' }]
];
const breaks = [
  ["break-normal", { "overflow-wrap": "normal", "word-break": "normal" }],
  ["break-word", { "overflow-wrap": "break-word" }],
  ["break-all", { "word-break": "break-all" }]
];
const textOverflows = [
  ["truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-ellipsis", { "text-overflow": "ellipsis" }],
  ["text-clip", { "text-overflow": "clip" }]
];
const textTransforms = [
  ["case-upper", { "text-transform": "uppercase" }],
  ["case-lower", { "text-transform": "lowercase" }],
  ["case-capital", { "text-transform": "capitalize" }],
  ["case-normal", { "text-transform": "none" }]
];
const fontStyles = [
  ["italic", { "font-style": "italic" }],
  ["not-italic", { "font-style": "normal" }]
];
const fontSmoothings = [
  ["antialiased", {
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "font-smoothing": "grayscale"
  }],
  ["subpixel-antialiased", {
    "-webkit-font-smoothing": "auto",
    "-moz-osx-font-smoothing": "auto",
    "font-smoothing": "auto"
  }]
];

const outlineStyle = ["none", "auto", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset", "inherit", "initial", "revert", "unset"];
const parseOutlineSize = (s) => {
  const propName = ["width", "offset"].find((item) => s.startsWith(item)) || "width";
  const size = handler.bracket.fraction.rem(s.replace(/^(offset\-|width\-|size\-)/, ""));
  if (size) {
    return {
      [`outline-${propName}`]: size
    };
  }
};
const outline = [
  ["outline-none", { "outline": "2px solid transparent", "outline-offset": "2px" }],
  ["outline", { "outline-style": "solid" }],
  [
    /^outline-(.+)$/,
    (match, config) => {
      const [, d] = match;
      if (d === "none") {
        return {
          "outline": "2px solid transparent",
          "outline-offset": "2px"
        };
      }
      if (outlineStyle.includes(d)) {
        return {
          "outline-style": d
        };
      }
      const colorSheet = colorResolver$1("outline-color", "outline-color")([
        match[0],
        match[1].replace(/^color-/, "")
      ], config);
      if (colorSheet)
        return colorSheet;
      const sizeSheet = parseOutlineSize(d);
      if (sizeSheet)
        return sizeSheet;
    }
  ]
];
const appearance = [
  ["appearance-none", {
    "appearance": "none",
    "-webkit-appearance": "none"
  }]
];
const placeholder = [
  [
    /^placeholder-opacity-(\d+)$/,
    ([, d]) => ({
      "placeholder-opacity": handler.bracket.percent(d)
    })
  ],
  [
    /^placeholder-(?!opacity)(.+)$/,
    (match, config) => {
      match[1] = match[1].replace(/^color-/, "");
      return colorResolver$1("placeholder-color", "placeholder-color")(match, config);
    }
  ]
];
const cssPropsStr = cssProps.join(", ");
const validateProperty$1 = (prop) => {
  if (prop && !cssProps.includes(prop))
    return;
  return prop || cssPropsStr;
};
const willChange = [
  [/^will-change-(.*)/, ([, p]) => {
    const w = validateProperty$1(p) || handler.global(p);
    if (w)
      return { "will-change": w };
  }]
];

const borders = [
  [/^border$/, handlerBorder],
  [/^(?:border|b)()-(.+)$/, handlerBorder],
  [/^(?:border|b)-([^-]+)(?:-(.+))?$/, handlerBorder],
  [/^(?:border|b)()-size-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-([^-]+)-size-(.+)$/, handlerBorderSize],
  [/^(?:border|b)()-(.+)$/, handlerBorderColor],
  [/^(?:border|b)-([^-]+)(?:-(.+))?$/, handlerBorderColor],
  [/^(?:border|b)-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-border-opacity": handler.bracket.percent(opacity) })],
  ["border-solid", { "border-style": "solid" }],
  ["border-dashed", { "border-style": "dashed" }],
  ["border-dotted", { "border-style": "dotted" }],
  ["border-double", { "border-style": "double" }],
  ["border-none", { "border-style": "none" }],
  [/^(?:border-)?(?:rounded|rd)$/, handlerRounded],
  [/^(?:border-)?(?:rounded|rd)(?:-([^-]+))?$/, handlerRounded],
  [/^(?:border-)?(?:rounded|rd)(?:-([^-]+))?(?:-([^-]+))?$/, handlerRounded]
];
function handlerBorder(m) {
  const borderSizes = handlerBorderSize(m);
  if (borderSizes) {
    return [
      ...borderSizes,
      ["border-style", "solid"]
    ];
  }
}
function handlerBorderSize([, a, b]) {
  const [d, s = "1"] = directionMap[a] ? [a, b] : ["", a];
  const v = handler.bracket.px(s);
  if (v != null) {
    return [
      ...directionMap[d].map((i) => [`border${i}-width`, v])
    ];
  }
}
function handlerBorderColor([, a, c], ctx) {
  if (c !== void 0) {
    const ofColor = colorResolver$1("border-color", "border")(["", c], ctx);
    if (ofColor) {
      const borders2 = directionMap[directionMap[a] ? a : ""].map((i) => colorResolver$1(`border${i}-color`, "border")(["", c], ctx));
      const borderObject = {};
      Object.assign(borderObject, ...borders2);
      return borderObject;
    }
  }
}
function handlerRounded([, a, b], { theme }) {
  const [d, s = "DEFAULT"] = cornerMap[a] ? [a, b] : ["", a];
  const v = theme.borderRadius?.[s] || handler.bracket.fraction.rem(s);
  if (v != null)
    return cornerMap[d].map((i) => [`border${i}-radius`, v]);
}

const transitionSwitchProps = ["all", "none"];
const transitionPropsStr = cssProps.join(", ");
const validateProperty = (prop) => {
  if (prop && ![...cssProps, ...transitionSwitchProps].includes(prop))
    return;
  return prop || transitionPropsStr;
};
const transitions = [
  [/^transition(?:-([a-z-]+))?(?:-(\d+))?$/, ([, prop, duration = "150"]) => {
    const transitionProperty = validateProperty(prop);
    if (!transitionProperty)
      return;
    return {
      "transition-property": transitionProperty,
      "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)",
      "transition-duration": `${duration}ms`
    };
  }],
  [/^duration-(\d+)$/, ([, duration = "150"]) => {
    return {
      "transition-duration": `${duration}ms`
    };
  }],
  ["ease", { "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)" }],
  ["ease-in", { "transition-timing-function": "cubic-bezier(0.4, 0, 1, 1)" }],
  ["ease-out", { "transition-timing-function": "cubic-bezier(0, 0, 0.2, 1)" }],
  ["ease-in-out", { "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)" }],
  [/^transition-delay-(\d+)$/, ([, v]) => ({ "transition-delay": `${v}ms` })],
  [/^transition-duration-(\d+)$/, ([, v]) => ({ "transition-duration": `${v}ms` })],
  [/^(?:transition-)?property-([a-z-]+)$/, ([, v]) => {
    const transitionProperty = validateProperty(v);
    if (transitionProperty)
      return { "transition-property": transitionProperty };
  }]
];

const flex = [
  ["flex", { display: "flex" }],
  ["inline-flex", { display: "inline-flex" }],
  ["flex-inline", { display: "inline-flex" }],
  ["flex-1", { flex: "1 1 0%" }],
  ["flex-auto", { flex: "1 1 auto" }],
  ["flex-initial", { flex: "0 1 auto" }],
  ["flex-none", { flex: "none" }],
  [/^flex-\[(.+)\]$/, ([, d]) => ({ flex: d })],
  ["flex-shrink", { "flex-shrink": 1 }],
  ["flex-shrink-0", { "flex-shrink": 0 }],
  ["flex-grow", { "flex-grow": 1 }],
  ["flex-grow-0", { "flex-grow": 0 }],
  ["flex-row", { "flex-direction": "row" }],
  ["flex-row-reverse", { "flex-direction": "row-reverse" }],
  ["flex-col", { "flex-direction": "column" }],
  ["flex-col-reverse", { "flex-direction": "column-reverse" }],
  ["flex-wrap", { "flex-wrap": "wrap" }],
  ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
  ["flex-nowrap", { "flex-wrap": "nowrap" }]
];

const weightMap = {
  thin: "100",
  extralight: "200",
  light: "300",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  black: "900"
};
const fonts = [
  [/^font-(\w+)$/, ([, d], { theme }) => {
    const font = theme.fontFamily?.[d];
    if (font) {
      return {
        "font-family": font
      };
    }
  }],
  [/^text-(.+)$/, ([, s = "base"], { theme }) => {
    const size = handler.bracket.rem(s);
    if (size)
      return { "font-size": size };
    const themed = toArray(theme.fontSize?.[s]);
    if (themed?.[0]) {
      const [size2, height] = themed;
      return {
        "font-size": size2,
        "line-height": height
      };
    }
  }],
  [/^text-size-(.+)$/, ([, s]) => {
    const raw = handler.bracket.rem(s);
    if (raw)
      return { "font-size": raw };
  }],
  [/^(?:font|fw)-?([^-]+)$/, ([, s]) => {
    const v = weightMap[s] || handler.number(s);
    if (v)
      return { "font-weight": v };
  }],
  [/^(?:leading|lh)-([^-]+)$/, ([, s], { theme }) => {
    const v = theme.lineHeight?.[s] || handler.bracket.rem(s);
    if (v !== null)
      return { "line-height": v };
  }],
  [/^tracking-([^-]+)$/, ([, s], { theme }) => {
    const v = theme.letterSpacing?.[s] || handler.bracket.rem(s);
    if (v !== null)
      return { "letter-spacing": v };
  }],
  [/^word-spacing-([^-]+)$/, ([, s], { theme }) => {
    const v = theme.wordSpacing?.[s] || handler.bracket.rem(s);
    if (v !== null)
      return { "word-spacing": v };
  }]
];
const tabSizes = [
  [/^tab-?([^-]*)$/, ([, s]) => {
    s = s || "4";
    const v = handler.bracket.global.number(s);
    if (v !== null) {
      return {
        "-moz-tab-size": v,
        "-o-tab-size": v,
        "tab-size": v
      };
    }
  }]
];
const textIndents = [
  [/^indent(?:-(.+))?$/, ([, s], { theme }) => {
    const v = theme.textIndent?.[s || "DEFAULT"] || handler.bracket.cssvar.fraction.rem(s);
    if (v != null)
      return { "text-indent": v };
  }]
];
const textStrokes = [
  [/^text-stroke(?:-(.+))?$/, ([, s], { theme }) => {
    const v = theme.textStrokeWidth?.[s || "DEFAULT"] || handler.bracket.cssvar.px(s);
    if (v != null)
      return { "-webkit-text-stroke-width": v };
  }],
  [/^text-stroke-(.+)$/, colorResolver$1("-webkit-text-stroke-color", "text-stroke")],
  [/^text-stroke-op(?:acity)?-?(.+)$/m, ([, opacity]) => ({ "--un-text-stroke-opacity": handler.bracket.percent(opacity) })]
];
const textShadows = [
  [/^text-shadow(?:-(.+))?$/, ([, s], { theme }) => {
    const v = theme.textShadow?.[s || "DEFAULT"] || handler.bracket.cssvar(s);
    if (v != null)
      return { "text-shadow": v };
  }]
];

const gaps = [
  [/^(?:flex-|grid-)?gap-([^-]+)$/, ([, s]) => {
    const v = handler.bracket.rem(s);
    if (v != null) {
      return {
        "grid-gap": v,
        "gap": v
      };
    }
  }],
  [/^(?:flex-|grid-)?gap-x-([^-]+)$/, ([, s]) => {
    const v = handler.bracket.rem(s);
    if (v != null) {
      return {
        "grid-column-gap": v,
        "column-gap": v
      };
    }
  }],
  [/^(?:flex-|grid-)?gap-y-([^-]+)$/, ([, s]) => {
    const v = handler.bracket.rem(s);
    if (v != null) {
      return {
        "grid-row-gap": v,
        "row-gap": v
      };
    }
  }]
];

const calSize = (s, theme) => toArray(theme.fontSize?.[s] || handler.bracket.rem(s))[0];
const autoDirection = (selector, theme) => {
  if (selector === "min")
    return "min-content";
  else if (selector === "max")
    return "max-content";
  else if (selector === "fr")
    return "minmax(0,1fr)";
  return calSize(selector, theme);
};
const grids = [
  ["grid", { display: "grid" }],
  ["inline-grid", { display: "inline-grid" }],
  [/^(?:grid-)?col-start-([\w.-]+)$/, ([, v]) => ({ "grid-column-start": `${v}` })],
  [/^(?:grid-)?col-end-([\w.]+)$/, ([, v]) => ({ "grid-column-end": `${v}` })],
  [/^(?:grid-)?row-start-([\w.-]+)$/, ([, v]) => ({ "grid-row-start": `${v}` })],
  [/^(?:grid-)?row-end-([\w.-]+)$/, ([, v]) => ({ "grid-row-end": `${v}` })],
  [/^(?:grid-)?(row|col)-(.+)$/, ([, d, v]) => {
    const key = d === "row" ? "grid-row" : "grid-column";
    let raw = handler.bracket(v);
    if (raw)
      return { [key]: raw };
    const parts = v.split("-");
    if (parts.length === 1 && parts[0] === "auto")
      return { [key]: parts[0] };
    if (parts[0] === "span") {
      if (parts[1] === "full")
        return { [key]: "1/-1" };
      raw = handler.number.bracket(parts[1])?.toString().replace(/_/g, " ");
      if (raw)
        return { [key]: `span ${raw}/span ${raw}` };
    }
  }],
  [/^(?:grid-)?auto-cols-([\w.-]+)$/, ([, v], { theme }) => ({ "grid-auto-columns": `${autoDirection(v, theme)}` })],
  [/^(?:grid-)?auto-flow-([\w.-]+)$/, ([, v]) => ({ "grid-auto-flow": `${v.replace("col", "column").split("-").join(" ")}` })],
  [/^(?:grid-)?auto-rows-([\w.-]+)$/, ([, v], { theme }) => ({ "grid-auto-rows": `${autoDirection(v, theme)}` })],
  [/^grid-cols-minmax-([\w.-]+)$/, ([, d]) => ({ "grid-template-columns": `repeat(auto-fill, minmax(${d}, 1fr))` })],
  [/^grid-rows-minmax-([\w.-]+)$/, ([, d]) => ({ "grid-template-rows": `repeat(auto-fill, minmax(${d}, 1fr))` })],
  [/^grid-cols-(\d+)$/, ([, d]) => ({ "grid-template-columns": `repeat(${d},minmax(0,1fr))` })],
  [/^grid-rows-(\d+)$/, ([, d]) => ({ "grid-template-rows": `repeat(${d},minmax(0,1fr))` })],
  [/^grid-cols-\[(.+)\]$/, ([, v]) => ({ "grid-template-columns": v.replace(/,/g, " ") })],
  [/^grid-rows-\[(.+)\]$/, ([, v]) => ({ "grid-template-rows": v.replace(/,/g, " ") })]
];

const overflowValues = [
  "auto",
  "hidden",
  "visible",
  "scroll"
];
const overflows = [
  [/^(?:overflow|of)-(.+)$/, ([, v]) => overflowValues.includes(v) ? { overflow: v } : void 0],
  [/^(?:overflow|of)-([xy])-(.+)$/, ([, d, v]) => overflowValues.includes(v) ? { [`overflow-${d}`]: v } : void 0]
];

const basicSet = ["auto", "start", "end", "center", "stretch"];
const positions = [
  ["relative", { position: "relative" }],
  ["absolute", { position: "absolute" }],
  ["fixed", { position: "fixed" }],
  ["sticky", { position: "sticky" }],
  ["static", { position: "static" }]
];
const justifies = [
  ["justify-start", { "justify-content": "flex-start" }],
  ["justify-end", { "justify-content": "flex-end" }],
  ["justify-center", { "justify-content": "center" }],
  ["justify-between", { "justify-content": "space-between" }],
  ["justify-around", { "justify-content": "space-around" }],
  ["justify-evenly", { "justify-content": "space-evenly" }],
  ...basicSet.map((i) => [`justify-items-${i}`, { "justify-items": i }]),
  ...basicSet.map((i) => [`justify-self-${i}`, { "justify-self": i }])
];
const orders = [
  [/^order-(.+)$/, ([, v]) => ({ order: { first: "-9999", last: "9999", none: "0" }[v] || handler.bracket.number(v) })]
];
const alignments = [
  ["content-start", { "align-content": "flex-start" }],
  ["content-end", { "align-content": "flex-end" }],
  ["content-center", { "align-content": "center" }],
  ["content-between", { "align-content": "space-between" }],
  ["content-around", { "align-content": "space-around" }],
  ["content-evenly", { "align-content": "space-evenly" }],
  ["items-start", { "align-items": "flex-start" }],
  ["items-end", { "align-items": "flex-end" }],
  ["items-center", { "align-items": "center" }],
  ["items-baseline", { "align-items": "baseline" }],
  ["items-stretch", { "align-items": "stretch" }],
  ["self-auto", { "align-self": "auto" }],
  ["self-start", { "align-self": "flex-start" }],
  ["self-end", { "align-self": "flex-end" }],
  ["self-center", { "align-self": "center" }],
  ["self-stretch", { "align-items": "stretch" }]
];
const placements = [
  ["place-content-start", { "place-content": "start" }],
  ["place-content-end", { "place-content": "end" }],
  ["place-content-center", { "place-content": "center" }],
  ["place-content-between", { "place-content": "space-between" }],
  ["place-content-around", { "place-content": "space-around" }],
  ["place-content-evenly", { "place-content": "space-evenly" }],
  ["place-content-stretch", { "place-content": "stretch" }],
  ...basicSet.map((i) => [`place-items-${i}`, { "place-items": i }]),
  ...basicSet.map((i) => [`place-self-${i}`, { "place-self": i }])
];
function handleInsetValue(v) {
  return { auto: "auto", full: "100%" }[v] ?? handler.bracket.fraction.cssvar.rem(v);
}
const insets = [
  [/^(top|left|right|bottom|inset)-(.+)$/, ([, d, v]) => ({ [d]: handleInsetValue(v) })],
  [/^inset-([xy])-(.+)$/, ([, d, v]) => {
    const r = handleInsetValue(v);
    if (r != null && d in directionMap)
      return directionMap[d].map((i) => [i.slice(1), r]);
  }]
];
const floats = [
  [/^float-(left|right|none)$/, ([, value]) => ({ float: value })],
  [/^clear-(left|right|both|none)$/, ([, value]) => ({ clear: value })]
];
const zIndexes = [
  ["z-auto", { "z-index": "auto" }],
  [/^z-([^-]+)$/, ([, v]) => ({ "z-index": handler.number(v) })]
];
const boxSizing = [
  [
    /^box-(border|content)$/,
    ([, value]) => ({
      "box-sizing": `${value}-box`
    })
  ]
];

const rings = [
  [/^ring-?(.*)$/, ([, d]) => {
    const value = handler.px(d || "1");
    if (value) {
      return {
        "--un-ring-inset": "var(--un-empty, )",
        "--un-ring-offset-width": "0px",
        "--un-ring-offset-color": "#fff",
        "--un-ring-color": "rgba(59, 130, 246, .5)",
        "--un-ring-offset-shadow": "var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)",
        "--un-ring-shadow": `var(--un-ring-inset) 0 0 0 calc(${value} + var(--un-ring-offset-width)) var(--un-ring-color)`,
        "-webkit-box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow, 0 0 #0000)",
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow, 0 0 #0000)"
      };
    }
  }],
  [/^ring-offset-?(.*)$/, ([, d]) => {
    const value = handler.px(d || "1");
    if (value) {
      return {
        "--un-ring-offset-width": value
      };
    }
  }],
  ["ring-inset", { "--un-ring-inset": "inset" }],
  ...ringColors,
  ...ringOffsetColors
];

const colorResolver = (body, theme) => {
  const data = parseColorUtil(body, theme);
  if (!data)
    return;
  const { color, rgba } = data;
  if (!color)
    return;
  if (rgba) {
    return {
      "--un-shadow-color": `${rgba.slice(0, 3).join(",")}`
    };
  } else {
    return {
      "--un-shadow-color": color
    };
  }
};
const boxShadows = [
  [/^shadow-?(.*)$/, ([, d], { theme }) => {
    const value = theme?.boxShadow?.[d || "DEFAULT"];
    if (value) {
      return {
        "--un-shadow-color": "0,0,0",
        "--un-shadow": value,
        "box-shadow": "var(--un-ring-offset-shadow, 0 0 #0000), var(--un-ring-shadow, 0 0 #0000), var(--un-shadow)"
      };
    }
    const color = colorResolver(d, theme);
    if (color)
      return color;
  }]
];

function getPropName(minmax, hw) {
  return `${minmax ? `${minmax}-` : ""}${hw === "h" ? "height" : "width"}`;
}
function getThemeValue(minmax, hw, theme, prop) {
  let str = `${hw === "h" ? "height" : "width"}`;
  if (minmax)
    str = `${minmax}${capitalize(str)}`;
  return theme[str]?.[prop];
}
const sizes = [
  [/^(?:(min|max)-)?(w|h)-(.+)$/, ([, m, w, s], { theme }) => {
    const v = getThemeValue(m, w, theme, s) || handler.bracket.cssvar.fraction.rem(s);
    if (v != null)
      return { [getPropName(m, w)]: v };
  }],
  [/^(?:(min|max)-)?(w)-screen-(.+)$/, ([, m, w, s], { theme }) => {
    const v = theme.breakpoints?.[s];
    if (v != null)
      return { [getPropName(m, w)]: v };
  }]
];
const aspectRatio = [
  ["aspect-ratio-auto", { "aspect-ratio": "auto" }],
  [/^aspect-ratio-(.+)$/, ([, d]) => {
    const v = (/^\d+\/\d+$/.test(d) ? d : null) || handler.bracket.cssvar.number(d);
    if (v != null)
      return { "aspect-ratio": v };
  }]
];

const paddings = [
  [/^pa?()-?(-?.+)$/, directionSize("padding")],
  [/^p-?([xy])-?(-?.+)$/, directionSize("padding")],
  [/^p-?([rltbse])-?(-?.+)$/, directionSize("padding")]
];
const margins = [
  [/^ma?()-?(-?.+)$/, directionSize("margin")],
  [/^m-?([xy])-?(-?.+)$/, directionSize("margin")],
  [/^m-?([rltbse])-?(-?.+)$/, directionSize("margin")]
];

const transformGpu = {
  transform: "rotate(var(--un-rotate)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) translate3d(var(--un-translate-x), var(--un-translate-y), var(--un-translate-z))",
  [CONTROL_BYPASS_PSEUDO_CLASS]: ""
};
const transformCpu = {
  transform: "rotate(var(--un-rotate)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z))",
  [CONTROL_BYPASS_PSEUDO_CLASS]: ""
};
const transformBase = {
  "--un-rotate": 0,
  "--un-scale-x": 1,
  "--un-scale-y": 1,
  "--un-scale-z": 1,
  "--un-skew-x": 0,
  "--un-skew-y": 0,
  "--un-translate-x": 0,
  "--un-translate-y": 0,
  "--un-translate-z": 0,
  ...transformCpu
};
const transforms = [
  ["transform", transformBase],
  [/^preserve-(3d|flat)$/, ([, value]) => ({ "transform-style": value === "3d" ? `preserve-${value}` : value })],
  [/^translate()-(.+)$/, handleTranslate],
  [/^translate-([xyz])-(.+)$/, handleTranslate],
  [/^scale()-(.+)$/, handleScale],
  [/^scale-([xyz])-(.+)$/, handleScale],
  [/^rotate-(.+)$/, handleRotate],
  [/^rotate-((?!\[)[^-]+?)(?:deg)?$/, handleRotateWithUnit],
  ["transform-gpu", transformGpu],
  ["transform-cpu", transformCpu],
  ["transform-none", { transform: "none" }],
  ["origin-center", { "transform-origin": "center" }],
  ["origin-top", { "transform-origin": "top" }],
  ["origin-top-right", { "transform-origin": "top right" }],
  ["origin-right", { "transform-origin": "right" }],
  ["origin-bottom-right", { "transform-origin": "bottom right" }],
  ["origin-bottom", { "transform-origin": "bottom" }],
  ["origin-bottom-left", { "transform-origin": "bottom left" }],
  ["origin-left", { "transform-origin": "left" }],
  ["origin-top-left", { "transform-origin": "top left" }]
];
function handleTranslate([, d, b]) {
  const v = handler.bracket.fraction.rem(b);
  if (v != null) {
    return [
      transformBase,
      [
        ...xyzMap[d].map((i) => [`--un-translate${i}`, v])
      ]
    ];
  }
}
function handleScale([, d, b]) {
  const v = handler.bracket.fraction.percent(b);
  if (v != null) {
    return [
      transformBase,
      [
        ...xyzMap[d].map((i) => [`--un-scale${i}`, v])
      ]
    ];
  }
}
function handleRotateWithUnit([, b]) {
  const v = handler.bracket.number(b);
  if (v != null) {
    return [
      transformBase,
      { "--un-rotate": `${v}deg` }
    ];
  }
}
function handleRotate([, b]) {
  const v = handler.bracket(b);
  if (v != null) {
    return [
      transformBase,
      { "--un-rotate": v }
    ];
  }
}

const variablesAbbrMap = {
  "visible": "visibility",
  "select": "user-select",
  "vertical": "vertical-align",
  "backface": "backface-visibility",
  "whitespace": "white-space",
  "break": "word-break",
  "b": "border-color",
  "border": "border-color",
  "color": "color",
  "case": "text-transform",
  "origin": "transform-origin",
  "bg": "background-color",
  "bg-opacity": "background-opacity",
  "tab": "tab-size",
  "underline": "text-decoration-thickness",
  "underline-offset": "text-underline-offset",
  "text": "color",
  "grid-cols": "grid-template-columns",
  "grid-rows": "grid-template-rows",
  "auto-flow": "grid-auto-flow",
  "row-start": "grid-row-start",
  "row-end": "grid-row-end",
  "justify": "justify-content",
  "content": "align-content",
  "items": "align-items",
  "self": "align-self",
  "object": "object-fit"
};
const cssVariables = [
  [/^(.+)-\$(.+)$/, ([, name, varname]) => {
    const prop = variablesAbbrMap[name];
    if (prop) {
      return {
        [prop]: `var(--${varname})`
      };
    }
  }],
  [/^(?:border|b)-([^-]+)-\$(.+)$/, ([, a, v]) => {
    if (a in directionMap)
      return directionMap[a].map((i) => [`border${i}-color`, `var(--${v})`]);
  }]
];

const questionMark = [
  [
    /^(where|\?)$/,
    (_, { constructCSS, generator }) => {
      if (generator.userConfig.envMode === "dev")
        return `@keyframes __un_qm{0%{box-shadow:inset 4px 4px #ff1e90, inset -4px -4px #ff1e90}100%{box-shadow:inset 8px 8px #3399ff, inset -8px -8px #3399ff}}
${constructCSS({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
    }
  ]
];

const textDecorations = [
  ["underline", { "text-decoration": "underline" }],
  ["line-through", { "text-decoration": "line-through" }],
  ["no-underline", { "text-decoration": "none" }],
  ["decoration-underline", { "text-decoration": "underline" }],
  ["decoration-line-through", { "text-decoration": "line-through" }],
  ["decoration-none", { "text-decoration": "none" }],
  [/^(?:underline|decoration)-(solid|double|dotted|dashed|wavy)$/, ([, d]) => ({ "text-decoration-style": d })],
  [/^(?:underline|decoration)-([^-]+)$/, ([, s]) => ({ "text-decoration-thickness": ["auto", "from-font"].includes(s) ? s : handler.bracket.px(s) })],
  [/^decoration-(.*)$/, ([, d]) => ({ "text-decoration-thickness": handler.bracket.px(d) })],
  [/^underline-offset-([^-]+)$/, ([, s]) => {
    const v = s === "auto" ? s : handler.bracket.px(s);
    if (v != null)
      return { "text-underline-offset": v };
  }],
  [/^(?:underline|decoration)-(.+)$/, (match, ctx) => {
    const result = colorResolver$1("text-decoration-color", "line")(match, ctx);
    if (result) {
      return {
        "-webkit-text-decoration-color": result["text-decoration-color"],
        ...result
      };
    }
  }],
  [/^(?:underline|decoration)-op(?:acity)?-?(.+)$/m, ([, opacity]) => ({ "--un-line-opacity": handler.bracket.percent(opacity) })]
];

const svgUtilities = [
  [/^fill-(.+)$/, colorResolver$1("fill", "fill")],
  [/^fill-op(?:acity)?-?(.+)$/m, ([, opacity]) => ({ "--un-fill-opacity": handler.bracket.percent(opacity) })],
  ["fill-none", { fill: "none" }],
  [/^stroke-(?:size-|width-)?(.+)$/, ([, s]) => {
    const v = handler.bracket.fraction.px.number(s);
    if (v)
      return { "stroke-width": v };
  }],
  [/^stroke-(.+)$/, colorResolver$1("stroke", "stroke")],
  [/^stroke-op(?:acity)?-?(.+)$/m, ([, opacity]) => ({ "--un-stroke-opacity": handler.bracket.percent(opacity) })],
  ["stroke-none", { stroke: "none" }]
];

const rules = [
  cssVariables,
  paddings,
  margins,
  displays,
  opacity,
  bgColors,
  svgUtilities,
  borders,
  contents,
  fonts,
  tabSizes,
  textIndents,
  textOverflows,
  textDecorations,
  textStrokes,
  textShadows,
  textTransforms,
  textAligns,
  textColors,
  fontStyles,
  fontSmoothings,
  boxShadows,
  rings,
  flex,
  grids,
  gaps,
  positions,
  sizes,
  aspectRatio,
  cursors,
  appearances,
  pointerEvents,
  resizes,
  verticalAligns,
  userSelects,
  whitespaces,
  breaks,
  overflows,
  outline,
  appearance,
  placeholder,
  positions,
  orders,
  justifies,
  alignments,
  placements,
  insets,
  floats,
  zIndexes,
  boxSizing,
  transitions,
  transforms,
  willChange,
  questionMark
].flat(1);

export { transitions as $, floats as A, zIndexes as B, boxSizing as C, questionMark as D, rings as E, boxShadows as F, sizes as G, aspectRatio as H, paddings as I, margins as J, cssProps as K, varEmpty as L, displays as M, appearances as N, cursors as O, pointerEvents as P, resizes as Q, userSelects as R, whitespaces as S, contents as T, breaks as U, textOverflows as V, textTransforms as W, fontStyles as X, fontSmoothings as Y, svgUtilities as Z, transforms as _, appearance as a, fonts as a0, tabSizes as a1, textIndents as a2, textStrokes as a3, textShadows as a4, cssVariables as a5, textDecorations as a6, borders as b, parseColorUtil as c, colorResolver$1 as d, opacity as e, textColors as f, bgColors as g, borderColors as h, ringColors as i, ringOffsetColors as j, flex as k, gaps as l, grids as m, overflows as n, outline as o, placeholder as p, positions as q, rules as r, justifies as s, textAligns as t, orders as u, verticalAligns as v, willChange as w, alignments as x, placements as y, insets as z };
