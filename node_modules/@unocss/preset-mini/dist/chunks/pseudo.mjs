import { toArray } from '@unocss/core';

const CONTROL_BYPASS_PSEUDO_CLASS = "$$no-pseudo";
const PseudoClasses = Object.fromEntries([
  "any-link",
  "link",
  "visited",
  "target",
  "hover",
  "active",
  "focus-visible",
  "focus-within",
  "focus",
  "autofill",
  "enabled",
  "disabled",
  "read-only",
  "read-write",
  "placeholder-shown",
  "default",
  "checked",
  "indeterminate",
  "valid",
  "invalid",
  "required",
  "optional",
  "root",
  "empty",
  ["even-of-type", "nth-of-type(even)"],
  ["even", "nth-child(even)"],
  ["odd-of-type", "nth-of-type(odd)"],
  ["odd", "nth-child(odd)"],
  "first-of-type",
  ["first", "first-child"],
  "last-of-type",
  ["last", "last-child"],
  "only-child",
  "only-of-type"
].map(toArray));
const PseudoElements = [
  "before",
  "after",
  "first-letter",
  "first-line",
  "selection"
];
const PseudoElementsRE = new RegExp(`^(${PseudoElements.join("|")})[:-]`);
const PseudoClassesStr = Object.keys(PseudoClasses).join("|");
const PseudoClassesRE = new RegExp(`^(${PseudoClassesStr})[:-]`);
const PseudoClassesNotRE = new RegExp(`^not-(${PseudoClassesStr})[:-]`);
const PseudoClassesGroupRE = new RegExp(`^group-((not-)?(${PseudoClassesStr}))[:-]`);
const PseudoClassesPeerRE = new RegExp(`^peer-((not-)?(${PseudoClassesStr}))[:-]`);
const variantPseudoElements = (input) => {
  const match = input.match(PseudoElementsRE);
  if (match) {
    return {
      matcher: input.slice(match[1].length + 1),
      selector: (s) => `${s}::${match[1]}`
    };
  }
};
function shouldAdd(entires) {
  return !entires.find((i) => i[0] === CONTROL_BYPASS_PSEUDO_CLASS) || void 0;
}
const variantPseudoClasses = {
  match: (input) => {
    let match = input.match(PseudoClassesRE);
    if (match) {
      const pseudo = PseudoClasses[match[1]] || match[1];
      return {
        matcher: input.slice(match[1].length + 1),
        selector: (s, body) => shouldAdd(body) && `${s}:${pseudo}`
      };
    }
    match = input.match(PseudoClassesNotRE);
    if (match) {
      const pseudo = PseudoClasses[match[1]] || match[1];
      return {
        matcher: input.slice(match[1].length + 5),
        selector: (s, body) => shouldAdd(body) && `${s}:not(:${pseudo})`
      };
    }
    match = input.match(PseudoClassesGroupRE);
    if (match) {
      let pseudo = PseudoClasses[match[3]] || match[3];
      if (match[2])
        pseudo = `not(:${pseudo})`;
      return {
        matcher: input.slice(match[1].length + 7),
        selector: (s, body) => shouldAdd(body) && s.includes(".group:") ? s.replace(/\.group:/, `.group:${pseudo}:`) : `.group:${pseudo} ${s}`
      };
    }
    match = input.match(PseudoClassesPeerRE);
    if (match) {
      let pseudo = PseudoClasses[match[3]] || match[3];
      if (match[2])
        pseudo = `not(:${pseudo})`;
      return {
        matcher: input.slice(match[1].length + 6),
        selector: (s, body) => shouldAdd(body) && s.includes(".peer:") ? s.replace(/\.peer:/, `.peer:${pseudo}:`) : `.peer:${pseudo}~${s}`
      };
    }
  },
  multiPass: true
};

export { CONTROL_BYPASS_PSEUDO_CLASS as C, PseudoClasses as P, variantPseudoElements as a, variantPseudoClasses as v };
